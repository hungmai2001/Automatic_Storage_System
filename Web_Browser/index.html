<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hệ thống gửi đồ bằng khuôn mặt</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        input {
            font-size: 20px;
            padding: 10px 20px;
            border: 2px solid #ccc;
            border-radius: 5px;
            margin: 10px;
        }
        input:hover {
            background-color: #ccc;
        }
        canvas {
            width: 100%; /* Chiều rộng tương đương với kích thước của cửa sổ */
            height: auto; /* Chiều cao tự động điều chỉnh theo tỉ lệ khung hình */
            display: block; /* Đảm bảo canvas được vẽ toàn bộ kích thước của nó */
        }
    </style>
  </head>
  <body onload="on_load();">
    <div id="connect">
      <input type="button" value="connect server" onclick="on_connect_server();">
      <input type="text" id="connect_input" name="connect_input" value="esp32-camera.local">
    </div>
    <div id="take">
      <input type="button" value="GIỮ ĐỒ" onclick="on_take_picture();">
      <input type="button" value="LẤY ĐỒ" onclick="on_take_picture_1();">
    </div>
    <div id="fail">
      Server connection fail.
    </div>
    <div>
      <canvas id="canvas_image" width="160" height="120"></canvas>
    </div>
  </body>

  <script>
    // https://qiita.com/magiclib/items/3aab45b6701cb973e896
    var web_socket = null;
    var giu_do = 1;
    var face_detect = false;
    function on_load()
    {
      document.getElementById('take').style.display = 'none';
      document.getElementById('fail').style.display = 'none';
    }

    function on_connect_server()
    {
      var text = document.getElementById('connect_input');
      console.log(text.value);
      var connection = "ws://" + text.value + ":80/ws";
      console.log(connection);

      //web_socket = new WebSocket('ws://192.168.10.161:80/ws'); // Specify server address
      web_socket = new WebSocket(connection);
      web_socket.binaryType = 'arraybuffer';
      web_socket.onmessage = on_message;
      web_socket.onerror = on_error;
      document.getElementById('take').style.display = 'inline';
      document.getElementById('connect').style.display = 'none';
    };

    function on_take_picture()
    {
      giu_do = 1;
      var text_input = "capture";
      web_socket.send(text_input);
    }

    function on_error(recv_data)
    {
      console.log("on_error");
      document.getElementById('take').style.display = 'none';
      document.getElementById('fail').style.display = 'inline';
    }

    function on_message(recv_data)
    {
      // console.log(recv_data.data);
      // console.log(typeof(recv_data.data));
      // console.log(recv_data.data.byteLength);

      if ( (1 == giu_do) ) {
        if ( (typeof(recv_data.data) == "object") && (false == face_detect) ) {
          // console.log(typeof(recv_data.data));
          var recv_image_data = new Uint8Array(recv_data.data);
          // console.log(recv_image_data);
          displayImage(recv_image_data);
        }
        else if ( (typeof(recv_data.data) == "object") && (true == face_detect) ) {
          console.log("receive image");
          saveImage(recv_image_data);
          console.log(recv_data.data);
          console.log(typeof(recv_data.data));
          console.log(recv_data.data.byteLength);
          face_detect = false;
        }
        else if ( (typeof(recv_data.data) == "string") && (false == face_detect) ) {
          console.log("start face image");
          face_detect = true;
        }
      }
      else {
        /* Do nothing */
      }
      // const endTime = new Date().getTime();
      // const timeTaken = endTime - startTime;
      // console.log("Function took " + timeTaken + " milliseconds");
    }

    async function displayImage(pixels) {
      // Kích thước hình ảnh
      const xres = 160;
      const yres = 120;
      
      // Tạo canvas và lấy context
      const canvas = document.getElementById('canvas_image');
      const scale = 3;
      canvas.width = xres*scale;
      canvas.height = yres*scale;
      const ctx = canvas.getContext('2d');

      // Tạo một ImageData object để quản lý dữ liệu hình ảnh
      const imgData = ctx.createImageData(xres, yres);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let ln = 0;
      // Duyệt qua từng hàng và cột của hình ảnh
      for (let y = 0; y < yres; y++) {
          for (let x = 0; x < xres; x++) {
              // Tính toán chỉ số pixel trong mảng pixels
              const i = (y * xres + x) << 1;

              // Chuyển đổi từ raw data sang định dạng hình ảnh
              const pixel16 = (0xffff & pixels[i + 1]) | ((0xffff & pixels[i]) << 8);

              // Chuyển đổi màu
              imgData.data[ln + 0] = ((pixel16 >> 8) & 0xF8);   // Red
              imgData.data[ln + 1] = ((pixel16 >> 3) & 0xFC);   // Green
              imgData.data[ln + 2] = ((pixel16 << 3) & 0xF8);   // Blue
              imgData.data[ln + 3] = 255; // Alpha channel, có thể điều chỉnh nếu cần

              ln += 4; // Di chuyển đến pixel tiếp theo trong imgData
          }
      }

      // Hiển thị hình ảnh trên canvas
      ctx.putImageData(imgData, 0, 0);
    }

    async function saveImage(pixels) {
      // Kích thước hình ảnh
      const xres = 160;
      const yres = 120;
      
      // Tạo canvas và lấy context
      const canvas = document.getElementById('canvas_image');
      const scale = 3;
      canvas.width = xres*scale;
      canvas.height = yres*scale;
      const ctx = canvas.getContext('2d');

      // Tạo một ImageData object để quản lý dữ liệu hình ảnh
      const imgData = ctx.createImageData(xres, yres);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let ln = 0;
      // Duyệt qua từng hàng và cột của hình ảnh
      for (let y = 0; y < yres; y++) {
          for (let x = 0; x < xres; x++) {
              // Tính toán chỉ số pixel trong mảng pixels
              const i = (y * xres + x) << 1;

              // Chuyển đổi từ raw data sang định dạng hình ảnh
              const pixel16 = (0xffff & pixels[i + 1]) | ((0xffff & pixels[i]) << 8);

              // Chuyển đổi màu
              imgData.data[ln + 0] = ((pixel16 >> 8) & 0xF8);   // Red
              imgData.data[ln + 1] = ((pixel16 >> 3) & 0xFC);   // Green
              imgData.data[ln + 2] = ((pixel16 << 3) & 0xF8);   // Blue
              imgData.data[ln + 3] = 255; // Alpha channel, có thể điều chỉnh nếu cần

              ln += 4; // Di chuyển đến pixel tiếp theo trong imgData
          }
      }
      ctx.putImageData(imgData, 0, 0);

      // Tạo một Blob từ dữ liệu của canvas
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error('Không thể tạo Blob từ canvas'));
            return;
          }

          // Tạo một URL đặc biệt cho Blob
          const url = URL.createObjectURL(blob);

          // Tạo một thẻ <a> để tạo và tải xuống file
          const a = document.createElement('a');
          a.href = url;
          a.download = 'image.png';
          document.body.appendChild(a);

          // Kích hoạt sự kiện click trên thẻ <a> để tải xuống file
          a.click();

          // Xóa thẻ <a> và giải phóng URL
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          resolve();
        }, 'image/png'); // Định dạng hình ảnh mong muốn (ở đây là PNG)
      });
    }

  </script>
</html>
